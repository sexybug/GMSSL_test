// GMSSL_test.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
//

#include "test.h"
#include "sm2.h"
#include "sm3.h"
#include "sm4.h"

#include <iostream>

void test_sm3_hash()
{
	const char* m_str = "6162636461626364616263646162636461626364616263646162636461626364"
		"6162636461626364616263646162636461626364616263646162636461626364"
		"6162636461626364616263646162636461626364616263646162636461626364"
		"61626364616263646162636461626364616263646162636461626364616263";
	const char* hash_str = "e9a39509f0654c8a7b65200d22f75fd83e56a41f39126c9200b95ff1b0821eb4";

	uint8_t m[127];
	int mlen = 127;
	HexString2Hex(m_str, mlen, m);
	uint8_t out[32];

	sm3_hash(m, mlen, out);
	print_u8("SM3 hash", out, sizeof(out));
}
void test_sm3_hmac()
{
	const char* key_str = "000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F";
	const char* m_str = "6162636461626364616263646162636461626364616263646162636461626364"
		"6162636461626364616263646162636461626364616263646162636461626364"
		"6162636461626364616263646162636461626364616263646162636461626364"
		"61626364616263646162636461626364616263646162636461626364616263";
	const char* hash_str = "8DCAC678E81F695645A9FFB7753F761CE39D86A442C5373B7037B44982C3F21F";

	uint8_t key[32], m[127];
	int key_len = 32;
	int mlen = 127;
	HexString2Hex(key_str, key_len, key);
	HexString2Hex(m_str, mlen, m);
	uint8_t out[32];

	sm3_hmac(key, key_len, m, mlen, out);
	print_u8("SM3 hmac", out, sizeof(out));
}

void test_sm4_ecb()
{
	const char* K_str = "2B7E151628AED2A6ABF7158809CF4F3C";

	const char* P_str = "6BC1BEE22E409F96E93D7E117393172A"
		"AE2D8A571E03AC9C9EB76FAC45AF8E51"
		"30C81C46A35CE411E5FBC1191A0A52EF"
		"F69F2445DF4F9B17AD2B417BE66C3710";

	const char* C_str = "A51411FF04A711443891FCE7AB842A29"
		"D5B50F46A9A730A0F590FFA776D99855"
		"C9A86A4D71447F4E873ADA4F388AF9B9"
		"2B25557B50514D155939E6EC940AD90E";

	size_t P_len = 64;
	uint8_t K[16], P[64], C[64], enc_out[64], dec_out[64];
	HexString2Hex(K_str, 16, K);
	HexString2Hex(P_str, 64, P);
	HexString2Hex(C_str, 64, C);

	sm4_ecb_enc(K, P, P_len, enc_out);
	print_u8("SM4 ECB encrypt", enc_out, P_len);

	sm4_ecb_dec(K, enc_out, P_len, dec_out);
	print_u8("SM4 ECB decrypt", dec_out, P_len);
}

void test_sm4_cbc()
{
	const char* K_str = "2B7E151628AED2A6ABF7158809CF4F3C";

	const char* IV_str = "000102030405060708090A0B0C0D0E0F";

	const char* P_str = "6BC1BEE22E409F96E93D7E117393172A"
		"AE2D8A571E03AC9C9EB76FAC45AF8E51"
		"30C81C46A35CE411E5FBC1191A0A52EF"
		"F69F2445DF4F9B17AD2B417BE66C3710";

	const char* C_str = "AC529AF989A62FCE9CDDC5FFB84125CA"
		"B168DD69DB3C0EEA1AB16DE6AEA43C59"
		"2C15567BFF8F707486C202C7BE59101F"
		"74A629B350CD7E11BE99998AF5206D6C";

	size_t P_len = 64;
	uint8_t K[16], IV[16], P[64], C[64], enc_out[64], dec_out[64];
	HexString2Hex(K_str, 16, K);
	HexString2Hex(IV_str, 16, IV);
	HexString2Hex(P_str, 64, P);
	HexString2Hex(C_str, 64, C);

	sm4_cbc_enc(K, IV, P, P_len, enc_out);
	print_u8("SM4 CBC encrypt", enc_out, P_len);

	sm4_cbc_dec(K, IV, enc_out, P_len, dec_out);
	print_u8("SM4 CBC decrypt", dec_out, P_len);
}
void sm2_compute_pub_key_test()
{
	uint8_t priv_key[32] = { 0x39, 0x45, 0x20, 0x8F, 0x7B, 0x21, 0x44, 0xB1, 0x3F, 0x36, 0xE3, 0x8A, 0xC6, 0xD3, 0x9F, 0x95, 0x88, 0x93, 0x93, 0x69, 0x28, 0x60, 0xB5, 0x1A, 0x42, 0xFB, 0x81, 0xEF, 0x4D, 0xF7, 0xC5, 0xB8 };
	uint8_t pub_key_std[64] = { 0x09,0xF9,0xDF,0x31,0x1E,0x54,0x21,0xA1,0x50,0xDD,0x7D,0x16,0x1E,0x4B,0xC5,0xC6,0x72,0x17,0x9F,0xAD,0x18,0x33,0xFC,0x07,0x6B,0xB0,0x8F,0xF3,0x56,0xF3,0x50,0x20 ,
	0xCC,0xEA,0x49,0x0C,0xE2,0x67,0x75,0xA5,0x2D,0xC6,0xEA,0x71,0x8C,0xC1,0xAA,0x60,0x0A,0xED,0x05,0xFB,0xF3,0x5E,0x08,0x4A,0x66,0x32,0xF6,0x07,0x2D,0xA9,0xAD,0x13 };

	uint8_t pub_key[64];
	sm2_compute_pub_key(priv_key, pub_key);
	print_u8("pub_key", pub_key, 64);
}
void sm2_enc_dec_test()
{
	uint8_t priv_key[32] = { 0x39, 0x45, 0x20, 0x8F, 0x7B, 0x21, 0x44, 0xB1, 0x3F, 0x36, 0xE3, 0x8A, 0xC6, 0xD3, 0x9F, 0x95, 0x88, 0x93, 0x93, 0x69, 0x28, 0x60, 0xB5, 0x1A, 0x42, 0xFB, 0x81, 0xEF, 0x4D, 0xF7, 0xC5, 0xB8 };
	uint8_t pub_key[64] = { 0x09,0xF9,0xDF,0x31,0x1E,0x54,0x21,0xA1,0x50,0xDD,0x7D,0x16,0x1E,0x4B,0xC5,0xC6,0x72,0x17,0x9F,0xAD,0x18,0x33,0xFC,0x07,0x6B,0xB0,0x8F,0xF3,0x56,0xF3,0x50,0x20 ,
	0xCC,0xEA,0x49,0x0C,0xE2,0x67,0x75,0xA5,0x2D,0xC6,0xEA,0x71,0x8C,0xC1,0xAA,0x60,0x0A,0xED,0x05,0xFB,0xF3,0x5E,0x08,0x4A,0x66,0x32,0xF6,0x07,0x2D,0xA9,0xAD,0x13 };

	uint8_t plaintext[19] = { 0x65,0x6E,0x63,0x72,0x79,0x70,0x74,0x69,0x6F,0x6E,0x20,0x73,0x74,0x61,0x6E,0x64,0x61,0x72,0x64 };
	size_t plaintext_len = 19;

	uint8_t ciphertext[256];
	int ciphertext_len;
	uint8_t decrypted[128];
	size_t decrypted_len = 0;

	sm2_enc(pub_key, plaintext, plaintext_len, ciphertext, &ciphertext_len);
	print_u8("ciphertext", ciphertext, ciphertext_len);

	sm2_dec(priv_key, ciphertext, ciphertext_len, decrypted, &decrypted_len);
	print_u8("decrypted", decrypted, decrypted_len);
}

void sm2_dec_test()
{
	uint8_t priv_key[32] = { 0x39, 0x45, 0x20, 0x8F, 0x7B, 0x21, 0x44, 0xB1, 0x3F, 0x36, 0xE3, 0x8A, 0xC6, 0xD3, 0x9F, 0x95, 0x88, 0x93, 0x93, 0x69, 0x28, 0x60, 0xB5, 0x1A, 0x42, 0xFB, 0x81, 0xEF, 0x4D, 0xF7, 0xC5, 0xB8 };

	uint8_t ciphertext[256] = { 0x04,0xEB,0xFC,0x71,0x8E,0x8D,0x17,0x98,0x62,0x04,0x32,0x26,0x8E,0x77,0xFE,0xB6,0x41,0x5E,0x2E,0xDE,0x0E,0x07,0x3C,0x0F,0x4F,0x64,0x0E,0xCD,0x2E,0x14,0x9A,0x73 ,
	0xE8,0x58,0xF9,0xD8,0x1E,0x54,0x30,0xA5,0x7B,0x36,0xDA,0xAB,0x8F,0x95,0x0A,0x3C,0x64,0xE6,0xEE,0x6A,0x63,0x09,0x4D,0x99,0x28,0x3A,0xFF,0x76,0x7E,0x12,0x4D,0xF0 ,
	0x59,0x98,0x3C,0x18,0xF8,0x09,0xE2,0x62,0x92,0x3C,0x53,0xAE,0xC2,0x95,0xD3,0x03,0x83,0xB5,0x4E,0x39,0xD6,0x09,0xD1,0x60,0xAF,0xCB,0x19,0x08,0xD0,0xBD,0x87,0x66 ,
	0x21,0x88,0x6C,0xA9,0x89,0xCA,0x9C,0x7D,0x58,0x08,0x73,0x07,0xCA,0x93,0x09,0x2D,0x65,0x1E,0xFA };
	size_t ciphertext_len = 96 + 19;
	uint8_t decrypted[128];
	size_t decrypted_len = 0;

	sm2_dec(priv_key, ciphertext, ciphertext_len, decrypted, &decrypted_len);
	print_u8("decrypted", decrypted, decrypted_len);
}


void sm2_sign_verify_test()
{
	uint8_t priv_key[32] = { 0x39, 0x45, 0x20, 0x8F, 0x7B, 0x21, 0x44, 0xB1, 0x3F, 0x36, 0xE3, 0x8A, 0xC6, 0xD3, 0x9F, 0x95, 0x88, 0x93, 0x93, 0x69, 0x28, 0x60, 0xB5, 0x1A, 0x42, 0xFB, 0x81, 0xEF, 0x4D, 0xF7, 0xC5, 0xB8 };
	uint8_t pub_key[64] = { 0x09,0xF9,0xDF,0x31,0x1E,0x54,0x21,0xA1,0x50,0xDD,0x7D,0x16,0x1E,0x4B,0xC5,0xC6,0x72,0x17,0x9F,0xAD,0x18,0x33,0xFC,0x07,0x6B,0xB0,0x8F,0xF3,0x56,0xF3,0x50,0x20 ,
	0xCC,0xEA,0x49,0x0C,0xE2,0x67,0x75,0xA5,0x2D,0xC6,0xEA,0x71,0x8C,0xC1,0xAA,0x60,0x0A,0xED,0x05,0xFB,0xF3,0x5E,0x08,0x4A,0x66,0x32,0xF6,0x07,0x2D,0xA9,0xAD,0x13 };

	uint8_t IDA[17] = { 0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38, '\0' };
	size_t IDA_len = 16;
	uint8_t M[14] = { 0x6D,0x65,0x73,0x73,0x61,0x67,0x65,0x20,0x64,0x69,0x67,0x65,0x73,0x74 };
	size_t M_len = 14;

	uint8_t signature[64];
	int sign_success = sm2_sign_ida(priv_key, IDA, IDA_len, M, M_len, signature);
	print_u8("signature", signature, 64);

	int verify = sm2_verify_ida(pub_key, IDA, IDA_len, M, M_len, signature);
	if (verify == 1) {
		std::cout << "Signature verification succeeded." << std::endl;
	}
	else {
		std::cout << "Signature verification failed." << std::endl;
	}
}

void sm2_verify_test()
{
	uint8_t pub_key[64] = { 0x09,0xF9,0xDF,0x31,0x1E,0x54,0x21,0xA1,0x50,0xDD,0x7D,0x16,0x1E,0x4B,0xC5,0xC6,0x72,0x17,0x9F,0xAD,0x18,0x33,0xFC,0x07,0x6B,0xB0,0x8F,0xF3,0x56,0xF3,0x50,0x20 ,
	0xCC,0xEA,0x49,0x0C,0xE2,0x67,0x75,0xA5,0x2D,0xC6,0xEA,0x71,0x8C,0xC1,0xAA,0x60,0x0A,0xED,0x05,0xFB,0xF3,0x5E,0x08,0x4A,0x66,0x32,0xF6,0x07,0x2D,0xA9,0xAD,0x13 };

	uint8_t IDA[17] = { 0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38, '\0' };
	size_t IDA_len = 16;
	uint8_t M[14] = { 0x6D,0x65,0x73,0x73,0x61,0x67,0x65,0x20,0x64,0x69,0x67,0x65,0x73,0x74 };
	size_t M_len = 14;

	uint8_t R_std[32] = { 0xF5,0xA0,0x3B,0x06,0x48,0xD2,0xC4,0x63,0x0E,0xEA,0xC5,0x13,0xE1,0xBB,0x81,0xA1,0x59,0x44,0xDA,0x38,0x27,0xD5,0xB7,0x41,0x43,0xAC,0x7E,0xAC,0xEE,0xE7,0x20,0xB3 };
	uint8_t S_std[32] = { 0xB1,0xB6,0xAA,0x29,0xDF,0x21,0x2F,0xD8,0x76,0x31,0x82,0xBC,0x0D,0x42,0x1C,0xA1,0xBB,0x90,0x38,0xFD,0x1F,0x7F,0x42,0xD4,0x84,0x0B,0x69,0xC4,0x85,0xBB,0xC1,0xAA };

	uint8_t signature[64];
	memcpy(signature, R_std, 32);
	memcpy(signature + 32, S_std, 32);

	int verify = sm2_verify_ida(pub_key, IDA, IDA_len, M, M_len, signature);
	if (verify == 1) {
		std::cout << "verification succeeded." << std::endl;
	}
	else {
		std::cout << "verification failed." << std::endl;
	}
}

void sm2_sign_verify_hash_test()
{
	uint8_t priv_key[32] = { 0x39, 0x45, 0x20, 0x8F, 0x7B, 0x21, 0x44, 0xB1, 0x3F, 0x36, 0xE3, 0x8A, 0xC6, 0xD3, 0x9F, 0x95, 0x88, 0x93, 0x93, 0x69, 0x28, 0x60, 0xB5, 0x1A, 0x42, 0xFB, 0x81, 0xEF, 0x4D, 0xF7, 0xC5, 0xB8 };
	uint8_t pub_key[64] = { 0x09,0xF9,0xDF,0x31,0x1E,0x54,0x21,0xA1,0x50,0xDD,0x7D,0x16,0x1E,0x4B,0xC5,0xC6,0x72,0x17,0x9F,0xAD,0x18,0x33,0xFC,0x07,0x6B,0xB0,0x8F,0xF3,0x56,0xF3,0x50,0x20 ,
	0xCC,0xEA,0x49,0x0C,0xE2,0x67,0x75,0xA5,0x2D,0xC6,0xEA,0x71,0x8C,0xC1,0xAA,0x60,0x0A,0xED,0x05,0xFB,0xF3,0x5E,0x08,0x4A,0x66,0x32,0xF6,0x07,0x2D,0xA9,0xAD,0x13 };

	uint8_t e_std[32] = { 0xF0,0xB4,0x3E,0x94,0xBA,0x45,0xAC,0xCA,0xAC,0xE6,0x92,0xED,0x53,0x43,0x82,0xEB,0x17,0xE6,0xAB,0x5A,0x19,0xCE,0x7B,0x31,0xF4,0x48,0x6F,0xDF,0xC0,0xD2,0x86,0x40 };

	uint8_t signature[64];
	sm2_sign_hash(priv_key, e_std, signature);
	print_u8("signature", signature, 64);

	int verify = sm2_verify_hash(pub_key, e_std, signature);
	if (verify == 1) {
		std::cout << "Signature verification succeeded." << std::endl;
	}
	else {
		std::cout << "Signature verification failed." << std::endl;
	}
}

void sm2_verify_hash_test()
{
	uint8_t priv_key[32] = { 0x39, 0x45, 0x20, 0x8F, 0x7B, 0x21, 0x44, 0xB1, 0x3F, 0x36, 0xE3, 0x8A, 0xC6, 0xD3, 0x9F, 0x95, 0x88, 0x93, 0x93, 0x69, 0x28, 0x60, 0xB5, 0x1A, 0x42, 0xFB, 0x81, 0xEF, 0x4D, 0xF7, 0xC5, 0xB8 };
	uint8_t pub_key[64] = { 0x09,0xF9,0xDF,0x31,0x1E,0x54,0x21,0xA1,0x50,0xDD,0x7D,0x16,0x1E,0x4B,0xC5,0xC6,0x72,0x17,0x9F,0xAD,0x18,0x33,0xFC,0x07,0x6B,0xB0,0x8F,0xF3,0x56,0xF3,0x50,0x20 ,
	0xCC,0xEA,0x49,0x0C,0xE2,0x67,0x75,0xA5,0x2D,0xC6,0xEA,0x71,0x8C,0xC1,0xAA,0x60,0x0A,0xED,0x05,0xFB,0xF3,0x5E,0x08,0x4A,0x66,0x32,0xF6,0x07,0x2D,0xA9,0xAD,0x13 };

	uint8_t e_std[32] = { 0xF0,0xB4,0x3E,0x94,0xBA,0x45,0xAC,0xCA,0xAC,0xE6,0x92,0xED,0x53,0x43,0x82,0xEB,0x17,0xE6,0xAB,0x5A,0x19,0xCE,0x7B,0x31,0xF4,0x48,0x6F,0xDF,0xC0,0xD2,0x86,0x40 };
	uint8_t R_std[32] = { 0xF5,0xA0,0x3B,0x06,0x48,0xD2,0xC4,0x63,0x0E,0xEA,0xC5,0x13,0xE1,0xBB,0x81,0xA1,0x59,0x44,0xDA,0x38,0x27,0xD5,0xB7,0x41,0x43,0xAC,0x7E,0xAC,0xEE,0xE7,0x20,0xB3 };
	uint8_t S_std[32] = { 0xB1,0xB6,0xAA,0x29,0xDF,0x21,0x2F,0xD8,0x76,0x31,0x82,0xBC,0x0D,0x42,0x1C,0xA1,0xBB,0x90,0x38,0xFD,0x1F,0x7F,0x42,0xD4,0x84,0x0B,0x69,0xC4,0x85,0xBB,0xC1,0xAA };

	uint8_t signature[64];
	memcpy(signature, R_std, 32);
	memcpy(signature + 32, S_std, 32);

	int verify = sm2_verify_hash(pub_key, e_std, signature);
	if (verify == 1) {
		std::cout << "verification succeeded." << std::endl;
	}
	else {
		std::cout << "verification failed." << std::endl;
	}
}

int main()
{
	sm2_compute_pub_key_test();
	sm2_enc_dec_test();
	sm2_dec_test();
	sm2_sign_verify_test();
	sm2_verify_test();
	sm2_sign_verify_hash_test();
	sm2_verify_hash_test();
	//test_sm3_hash();
	//test_sm3_hmac();
	//test_sm4_ecb();
	//test_sm4_cbc();
}

// 运行程序: Ctrl + F5 或调试 >“开始执行(不调试)”菜单
// 调试程序: F5 或调试 >“开始调试”菜单

// 入门使用技巧: 
//   1. 使用解决方案资源管理器窗口添加/管理文件
//   2. 使用团队资源管理器窗口连接到源代码管理
//   3. 使用输出窗口查看生成输出和其他消息
//   4. 使用错误列表窗口查看错误
//   5. 转到“项目”>“添加新项”以创建新的代码文件，或转到“项目”>“添加现有项”以将现有代码文件添加到项目
//   6. 将来，若要再次打开此项目，请转到“文件”>“打开”>“项目”并选择 .sln 文件
